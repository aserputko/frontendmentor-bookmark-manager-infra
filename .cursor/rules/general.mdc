---
alwaysApply: true
---
# Cursor AI Rules - DevOps/Infrastructure Repository

## Repository Purpose
This repository manages infrastructure as code (IaC) using Terraform for AWS resources, with CI/CD automation via GitHub Actions.

## Core Technologies
- **Cloud Provider**: AWS
- **IaC Tool**: Terraform (latest stable version)
- **CI/CD**: GitHub Actions
- **Version Control**: Git
- **Additional Tools**: tflint, tfsec, Terragrunt, SOPS/AWS Secrets Manager

## Terraform Standards

### File Organization
- Use modular structure: separate environments (dev, staging, prod) into distinct directories
- Standard file naming: `main.tf`, `variables.tf`, `outputs.tf`, `providers.tf`, `versions.tf`
- Group related resources logically within modules
- Use `terraform.tfvars` for environment-specific values (never commit secrets)

### Coding Practices
- Always use Terraform >= 1.5.0 features (native test framework, import blocks)
- Pin provider versions explicitly in `versions.tf`
- Use `terraform fmt` for consistent formatting
- Validate with `terraform validate` before commits
- Implement resource naming conventions: `${var.environment}-${var.project}-${resource_type}`
- Use data sources instead of hardcoded values when possible
- Leverage remote state with S3 backend and DynamoDB locking
- Tag all resources with: Environment, Project, ManagedBy (Terraform), Owner, CostCenter

### Variables and Outputs
- Define comprehensive variable descriptions
- Use validation blocks for input constraints
- Set sensible defaults where appropriate
- Mark sensitive outputs with `sensitive = true`
- Document all outputs with descriptions

### Security Best Practices
- Never commit AWS credentials or secrets to version control
- Use AWS IAM roles with least privilege principle
- Scan code with `tfsec` for security vulnerabilities
- Encrypt all sensitive data at rest and in transit
- Use AWS Secrets Manager or SOPS for secret management
- Enable MFA for production resource modifications
- Implement backup and disaster recovery strategies

## AWS Best Practices

### Resource Management
- Use AWS Organizations for multi-account strategy
- Implement cost allocation tags on all resources
- Enable CloudTrail logging in all regions
- Set up AWS Config for compliance monitoring
- Use VPC flow logs for network monitoring
- Implement proper IAM policies with conditions

### High Availability & Reliability
- Deploy across multiple availability zones
- Use Auto Scaling Groups where appropriate
- Implement health checks and monitoring
- Set up CloudWatch alarms for critical metrics
- Use Application Load Balancers for traffic distribution

### Cost Optimization
- Use appropriate instance types and sizes
- Implement auto-scaling policies
- Leverage Reserved Instances and Savings Plans for predictable workloads
- Enable S3 lifecycle policies
- Use AWS Cost Explorer tags for cost attribution

## GitHub Actions Standards

### Workflow Structure
- Use reusable workflows for common patterns
- Implement proper secret management with GitHub Secrets
- Use environment protection rules for production deployments
- Implement manual approval gates for production changes
- Cache Terraform plugins to speed up runs

### CI/CD Pipeline Stages
1. **Validation**: `terraform fmt -check`, `terraform validate`, `tflint`
2. **Security Scanning**: `tfsec`, `checkov`
3. **Plan**: `terraform plan` with output artifact
4. **Approval**: Manual approval for production
5. **Apply**: `terraform apply` with plan file
6. **Documentation**: Auto-generate README with terraform-docs

### Workflow Best Practices
- Use matrix strategy for multi-environment deployments
- Implement drift detection on schedule
- Store Terraform plan artifacts for review
- Use OIDC for GitHub Actions AWS authentication (no long-lived credentials)
- Set appropriate timeouts for all jobs
- Implement proper error handling and notifications

## Code Review Guidelines

### Pull Request Requirements
- All PRs must include `terraform plan` output in comments
- Security scan results must pass before merge
- At least one approval required from team members
- Branch protection rules enforced on main/production branches
- PR description must explain infrastructure changes and impact

### Review Checklist
- [ ] Code follows Terraform style guide
- [ ] All resources properly tagged
- [ ] Security scan passes (tfsec/checkov)
- [ ] State backend configured correctly
- [ ] Documentation updated (README, comments)
- [ ] Variables have validation and descriptions
- [ ] Outputs documented
- [ ] No hardcoded secrets or credentials
- [ ] Proper IAM permissions (least privilege)
- [ ] Cost impact assessed

## Documentation Standards

### Required Documentation
- README.md in each module/environment with:
  - Purpose and scope
  - Prerequisites
  - Usage examples
  - Input variables table
  - Output values table
  - Resource dependencies
- Architecture diagrams for complex infrastructure
- Runbooks for common operations and troubleshooting
- Change log for major infrastructure modifications

### Comments and Annotations
- Explain complex logic or non-obvious decisions
- Document why specific configurations are chosen
- Link to relevant AWS documentation or RFCs
- Note any temporary workarounds with TODO comments

## Git Workflow

### Branch Strategy
- `main` branch: production-ready code
- `develop` branch: integration branch for features
- Feature branches: `feature/<description>`
- Hotfix branches: `hotfix/<description>`
- Environment branches (if needed): `env/<environment>`

### Commit Messages
- Use conventional commits format: `type(scope): description`
- Types: feat, fix, docs, refactor, test, chore
- Include ticket/issue numbers when applicable
- Example: `feat(vpc): add NAT gateway for private subnets (#123)`

## Testing Strategy

### Automated Testing
- Use Terraform's native test framework for integration tests
- Implement `terraform-compliance` for policy-as-code testing
- Run tests in isolated AWS accounts/environments
- Use Terratest for complex validation scenarios
- Validate `terraform plan` output in CI pipeline

### Manual Testing
- Test in dev environment first
- Verify changes in staging before production
- Document test results in PR
- Perform smoke tests after deployment

## Monitoring and Observability

### CloudWatch Integration
- Create dashboards for infrastructure metrics
- Set up alarms for critical thresholds
- Use CloudWatch Logs Insights for log analysis
- Implement composite alarms for complex scenarios

### Infrastructure Monitoring
- Monitor Terraform state file changes
- Track drift between actual and desired state
- Alert on failed GitHub Actions workflows
- Monitor AWS service quotas and limits

## Emergency Procedures

### Rollback Strategy
- Keep previous Terraform state versions
- Document rollback procedures for each major change
- Maintain ability to quickly revert to last known good state
- Test rollback procedures regularly

### Incident Response
- Access to AWS console for emergency manual changes
- Document all manual changes made during incidents
- Create follow-up tasks to codify emergency changes in Terraform
- Post-incident review and documentation updates

## Modern DevOps Practices

### Infrastructure as Code Principles
- Everything in version control
- Immutable infrastructure preferred over mutable
- Use blue-green or canary deployment strategies where applicable
- Implement GitOps workflows

### Automation Philosophy
- Automate repetitive tasks
- Self-service infrastructure provisioning via PRs
- Automated compliance checking
- Automated documentation generation

### Continuous Improvement
- Regular dependency updates (Terraform, providers, actions)
- Periodic security audits
- Cost optimization reviews
- Performance benchmarking and optimization

## Tools and Utilities

### Required Tools
- `terraform` (latest stable)
- `tflint` (Terraform linter)
- `tfsec` (security scanner)
- `terraform-docs` (documentation generator)
- `aws-cli` (AWS command line interface)
- `pre-commit` (Git hooks framework)

### Recommended Tools
- `terragrunt` (DRY Terraform configurations)
- `checkov` (additional security scanning)
- `infracost` (cost estimation)
- `terraform-compliance` (BDD testing)
- `atlantis` (Terraform PR automation)

## Environment-Specific Considerations

### Development
- Use smaller instance types
- Implement auto-shutdown for cost savings
- Allow more permissive access for testing
- Shorter retention periods for logs

### Staging
- Mirror production architecture
- Use production-like data (anonymized)
- Test disaster recovery procedures
- Validate monitoring and alerting

### Production
- Multi-AZ deployment mandatory
- Enhanced monitoring and alerting
- Strict access controls and audit logging
- Regular backup verification
- Change management process required
- Manual approval for all changes
